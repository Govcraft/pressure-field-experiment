//! The coordination kernel: tick-based pressure descent with decay.
//!
//! This module provides the async actor-based kernel using acton-reactive.
//!
//! ## Usage
//!
//! ```ignore
//! use survival_kernel::{AsyncKernelBuilder, KernelConfig};
//! use acton_reactive::prelude::*;
//!
//! // Create runtime and spawn actors
//! let mut runtime = ActonApp::launch_async().await;
//!
//! // Build kernel - sensors self-register via broker
//! let kernel = AsyncKernelBuilder::new(config, artifact)
//!     .add_sensor(Box::new(MySensor))
//!     .spawn(&mut runtime)
//!     .await;
//!
//! // Spawn patch actors separately - they self-register via PatchActorReady
//! let llm_actor = LlmActor::new(config);
//! llm_actor.spawn(&mut runtime).await;
//!
//! // Send Tick messages to drive the kernel
//! kernel.send(Tick { now_ms: 0 }).await;
//! ```

use std::collections::HashMap;
use std::sync::Arc;

use acton_reactive::prelude::*;

use crate::actors::{KernelCoordinator, RegionActor};
use crate::messages::Tick;
use crate::artifact::Artifact;
use crate::config::KernelConfig;
use crate::messages::{
    PatchActorsReady, RegisterRegionActors, SensorsReady, StopReason, WaitForPatchActors,
    WaitForSensors,
};
use crate::pressure::Sensor;
use crate::region::{Patch, RegionId};

/// Final result of running the kernel to completion.
#[derive(Debug, Clone)]
pub struct KernelResult {
    /// Total ticks executed
    pub ticks_executed: usize,
    /// Final total pressure
    pub final_pressure: f64,
    /// Why the kernel stopped
    pub stop_reason: StopReason,
    /// All patches that were applied during the run
    pub applied_patches: Vec<Patch>,
    /// Total prompt tokens used
    pub prompt_tokens: u32,
    /// Total completion tokens generated
    pub completion_tokens: u32,
    /// Final artifact source (if artifact supports source())
    pub final_source: Option<String>,
    /// Per-tick results for detailed metrics
    pub tick_results: Vec<TickResult>,
    /// Pressure history (one entry per tick)
    pub pressure_history: Vec<f64>,
}

/// Result of a single tick.
#[derive(Debug, Default, Clone)]
pub struct TickResult {
    /// Patches that were applied
    pub applied: Vec<Patch>,
    /// Regions that were evaluated but not patched
    pub evaluated: usize,
    /// Regions that were skipped (inhibited)
    pub skipped: usize,
    /// Total pressure across all regions
    pub total_pressure: f64,
    /// Velocity: rate of pressure change (dP/dt)
    pub velocity: f64,
    /// Acceleration: rate of velocity change (d²P/dt²)
    pub acceleration: f64,
    /// Total prompt tokens used by LLM actors this tick
    pub prompt_tokens: u32,
    /// Total completion tokens generated by LLM actors this tick
    pub completion_tokens: u32,
    /// Whether the artifact is now complete
    pub is_complete: bool,
}

/// Apply exponential decay with the given half-life.
pub fn half_life_decay(value: &mut f64, dt_ms: u64, half_life_ms: u64) {
    if half_life_ms == 0 {
        return;
    }
    let lambda = std::f64::consts::LN_2 / half_life_ms as f64;
    *value *= (-lambda * dt_ms as f64).exp();
}

/// Builder for creating an async kernel with parallel execution.
///
/// Spawns RegionActors for each region in the artifact, providing:
/// - Natural conflict resolution via mailbox serialization
/// - Post-patch validation to ensure pressure reduction (δ_min > 0)
/// - Local state ownership (stigmergy model from paper)
///
/// Uses the broker pub/sub pattern for actor registration:
/// - Sensors self-register via `SensorReady` broadcast
/// - Patch actors self-register via `PatchActorReady` broadcast
pub struct AsyncKernelBuilder {
    coordinator: KernelCoordinator,
    /// Sensors to spawn (they self-register via SensorReady broadcast)
    sensors: Vec<Arc<dyn Sensor>>,
    /// Validation sensor for RegionActors (first sensor added)
    validation_sensor: Option<Arc<dyn Sensor>>,
}

impl AsyncKernelBuilder {
    /// Create a new async kernel builder.
    pub fn new(config: KernelConfig, artifact: Box<dyn Artifact>) -> Self {
        Self {
            coordinator: KernelCoordinator::new(config, artifact),
            sensors: Vec::new(),
            validation_sensor: None,
        }
    }

    /// Register a sensor for measurement and validation.
    ///
    /// The first sensor added is also used for post-patch validation
    /// in RegionActors to ensure patches reduce pressure.
    ///
    /// Sensors are spawned during `spawn()` and self-register with the
    /// coordinator via `SensorReady` broker broadcast.
    pub fn add_sensor(mut self, sensor: Box<dyn Sensor>) -> Self {
        let sensor_arc: Arc<dyn Sensor> = Arc::from(sensor);
        // First sensor is used for validation
        if self.validation_sensor.is_none() {
            self.validation_sensor = Some(sensor_arc.clone());
        }
        self.sensors.push(sensor_arc);
        self
    }

    /// Spawn the kernel, sensor actors, and region actors.
    ///
    /// Returns the coordinator's actor handle. To run ticks:
    /// 1. Send `Tick { now_ms }` messages to the coordinator
    /// 2. Receive `TickComplete { result }` replies
    ///
    /// Sensors are spawned and self-register via `SensorReady` broker broadcast.
    pub async fn spawn(self, runtime: &mut ActorRuntime) -> ActorHandle {
        use crate::actors::SensorActor;

        // Get artifact info before moving to coordinator
        let region_ids: Vec<RegionId> = self.coordinator.artifact.region_ids();
        let region_views: Vec<_> = region_ids
            .iter()
            .filter_map(|rid| self.coordinator.artifact.read_region(*rid).ok().map(|v| (*rid, v)))
            .collect();
        let pressure_axes = self.coordinator.config.pressure_axes.clone();
        let validation_sensor = self.validation_sensor.clone();

        // Spawn the coordinator first (it subscribes to SensorReady)
        let coordinator_handle = self.coordinator.spawn(runtime).await;

        // Spawn sensor actors - they self-register via SensorReady broadcast
        for sensor in self.sensors {
            let sensor_actor = SensorActor::new(sensor);
            sensor_actor.spawn(runtime).await;
        }

        // Spawn RegionActors if we have a validation sensor
        if let Some(sensor) = validation_sensor {
            let mut region_actors: HashMap<RegionId, ActorHandle> = HashMap::new();

            for (rid, view) in region_views {
                let region_actor = RegionActor::new(
                    rid,
                    view.kind,
                    view.content,
                    view.metadata,
                    coordinator_handle.clone(),
                    sensor.clone(),
                    pressure_axes.clone(),
                );
                let handle = region_actor.spawn(runtime, 0).await;
                region_actors.insert(rid, handle);
            }

            // Register region actors with coordinator
            coordinator_handle
                .send(RegisterRegionActors {
                    actors: region_actors,
                })
                .await;
        }

        coordinator_handle
    }

    /// Run the kernel to completion and return the final result.
    ///
    /// This method:
    /// 1. Spawns all actors (coordinator, sensors, regions, tick actor)
    /// 2. Waits for patch actors to register
    /// 3. Starts the tick loop
    /// 4. Waits for `KernelComplete` (from TickActor)
    /// 5. Returns the final result
    ///
    /// The caller should spawn patch actors before calling this method.
    /// Use `WaitForPatchActors` to synchronize startup.
    pub async fn run(self, runtime: &mut ActorRuntime, expected_patch_actors: usize) -> KernelResult {
        use crate::actors::SensorActor;

        // Get artifact info and config before moving
        let config = self.coordinator.config.clone();
        let region_ids: Vec<RegionId> = self.coordinator.artifact.region_ids();
        let region_views: Vec<_> = region_ids
            .iter()
            .filter_map(|rid| self.coordinator.artifact.read_region(*rid).ok().map(|v| (*rid, v)))
            .collect();
        let pressure_axes = config.pressure_axes.clone();
        let validation_sensor = self.validation_sensor.clone();

        // Spawn the coordinator first
        let coordinator_handle = self.coordinator.spawn(runtime).await;

        // Spawn sensor actors (capture count before moving)
        let sensor_count = self.sensors.len();
        for sensor in self.sensors {
            let sensor_actor = SensorActor::new(sensor);
            sensor_actor.spawn(runtime).await;
        }

        // Spawn RegionActors
        if let Some(sensor) = validation_sensor {
            let mut region_actors: HashMap<RegionId, ActorHandle> = HashMap::new();

            for (rid, view) in region_views {
                let region_actor = RegionActor::new(
                    rid,
                    view.kind,
                    view.content,
                    view.metadata,
                    coordinator_handle.clone(),
                    sensor.clone(),
                    pressure_axes.clone(),
                );
                let handle = region_actor.spawn(runtime, 0).await;
                region_actors.insert(rid, handle);
            }

            coordinator_handle
                .send(RegisterRegionActors {
                    actors: region_actors,
                })
                .await;
        }

        // Create observer to collect TickComplete results
        let (tick_tx, mut tick_rx) = tokio::sync::mpsc::channel::<TickResult>(1000);
        let tick_observer = TickResultObserver::new(tick_tx);
        tick_observer.spawn(runtime).await;

        // Create observers to wait for registrations
        let (sensors_tx, mut sensors_rx) = tokio::sync::mpsc::channel::<SensorsReady>(1);
        let (actors_tx, mut actors_rx) = tokio::sync::mpsc::channel::<PatchActorsReady>(1);

        // Spawn SensorsReady observer
        if sensor_count > 0 {
            let sensors_observer = SensorsReadyObserver::new(sensors_tx);
            sensors_observer.spawn(runtime).await;
        }

        // Spawn PatchActorsReady observer
        if expected_patch_actors > 0 {
            let actors_observer = PatchActorsReadyObserver::new(actors_tx);
            actors_observer.spawn(runtime).await;
        }

        // Wait for sensors to register
        if sensor_count > 0 {
            coordinator_handle
                .send(WaitForSensors {
                    expected_count: sensor_count,
                })
                .await;
            // Wait for the SensorsReady broadcast
            sensors_rx.recv().await;
        }

        // Wait for patch actors to register
        if expected_patch_actors > 0 {
            coordinator_handle
                .send(WaitForPatchActors {
                    expected_count: expected_patch_actors,
                })
                .await;
            // Wait for the PatchActorsReady broadcast
            actors_rx.recv().await;
        }

        // Run the tick loop directly (not inside an actor handler)
        let interval_ms = config.tick_interval_ms;
        let max_ticks = config.max_ticks;
        let stable_threshold = config.stable_threshold;

        let mut tick_results = Vec::new();
        let mut applied_patches = Vec::new();
        let mut pressure_history = Vec::new();
        let mut prompt_tokens = 0u32;
        let mut completion_tokens = 0u32;
        let mut current_tick = 0usize;
        let mut stable_ticks = 0usize;
        let mut stop_reason = StopReason::MaxTicks;
        let mut final_pressure = 0.0;

        tracing::info!(
            interval_ms,
            max_ticks,
            stable_threshold,
            "Starting tick loop"
        );

        loop {
            current_tick += 1;

            let now_ms = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as u64;

            // Send Tick to coordinator
            coordinator_handle.send(Tick { now_ms }).await;

            // Wait for TickComplete via the observer channel
            let Some(result) = tick_rx.recv().await else {
                tracing::warn!("TickComplete channel closed unexpectedly");
                break;
            };

            // Track results
            pressure_history.push(result.total_pressure);
            prompt_tokens += result.prompt_tokens;
            completion_tokens += result.completion_tokens;
            applied_patches.extend(result.applied.clone());
            final_pressure = result.total_pressure;

            // Track stability (consecutive ticks with no patches)
            if result.applied.is_empty() {
                stable_ticks += 1;
            } else {
                stable_ticks = 0;
            }

            let is_complete = result.is_complete;
            tick_results.push(result);

            // Check termination conditions
            if is_complete {
                stop_reason = StopReason::Complete;
                break;
            } else if max_ticks > 0 && current_tick >= max_ticks {
                stop_reason = StopReason::MaxTicks;
                break;
            } else if stable_threshold > 0 && stable_ticks >= stable_threshold {
                stop_reason = StopReason::Converged { stable_ticks };
                break;
            }

            // Wait for the interval before next tick
            tokio::time::sleep(std::time::Duration::from_millis(interval_ms)).await;
        }

        tracing::info!(
            ticks_executed = current_tick,
            ?stop_reason,
            final_pressure = format!("{:.3}", final_pressure),
            "Kernel complete"
        );

        KernelResult {
            ticks_executed: current_tick,
            final_pressure,
            stop_reason,
            applied_patches,
            prompt_tokens,
            completion_tokens,
            final_source: None, // TODO: query from artifact via SaveArtifact
            tick_results,
            pressure_history,
        }
    }
}

/// Internal observer actor to collect TickComplete broadcasts.
struct TickResultObserver {
    tx: tokio::sync::mpsc::Sender<TickResult>,
}

impl TickResultObserver {
    fn new(tx: tokio::sync::mpsc::Sender<TickResult>) -> Self {
        Self { tx }
    }

    async fn spawn(self, runtime: &mut ActorRuntime) {
        use crate::messages::TickComplete;

        #[derive(Default, Clone, Debug)]
        struct State {
            tx: Option<tokio::sync::mpsc::Sender<TickResult>>,
        }

        let mut actor = runtime.new_actor_with_name::<State>("TickResultObserver".to_string());
        actor.model.tx = Some(self.tx);

        // Subscribe to TickComplete broadcasts
        actor.handle().subscribe::<TickComplete>().await;

        actor.act_on::<TickComplete>(|actor, context| {
            let msg = context.message();
            let mut result = msg.result.clone();
            result.is_complete = msg.is_complete;
            let tx = actor.model.tx.clone();
            Reply::pending(async move {
                if let Some(tx) = tx {
                    let _ = tx.send(result).await;
                }
            })
        });

        actor.start().await;
    }
}

/// Internal observer actor to wait for SensorsReady broadcast.
struct SensorsReadyObserver {
    tx: tokio::sync::mpsc::Sender<SensorsReady>,
}

impl SensorsReadyObserver {
    fn new(tx: tokio::sync::mpsc::Sender<SensorsReady>) -> Self {
        Self { tx }
    }

    async fn spawn(self, runtime: &mut ActorRuntime) {
        #[derive(Default, Clone, Debug)]
        struct State {
            tx: Option<tokio::sync::mpsc::Sender<SensorsReady>>,
        }

        let mut actor = runtime.new_actor_with_name::<State>("SensorsReadyObserver".to_string());
        actor.model.tx = Some(self.tx);

        // Subscribe to SensorsReady broadcasts
        actor.handle().subscribe::<SensorsReady>().await;

        actor.act_on::<SensorsReady>(|actor, context| {
            let msg = context.message().clone();
            let tx = actor.model.tx.clone();
            Reply::pending(async move {
                if let Some(tx) = tx {
                    let _ = tx.send(msg).await;
                }
            })
        });

        actor.start().await;
    }
}

/// Internal observer actor to wait for PatchActorsReady broadcast.
struct PatchActorsReadyObserver {
    tx: tokio::sync::mpsc::Sender<PatchActorsReady>,
}

impl PatchActorsReadyObserver {
    fn new(tx: tokio::sync::mpsc::Sender<PatchActorsReady>) -> Self {
        Self { tx }
    }

    async fn spawn(self, runtime: &mut ActorRuntime) {
        #[derive(Default, Clone, Debug)]
        struct State {
            tx: Option<tokio::sync::mpsc::Sender<PatchActorsReady>>,
        }

        let mut actor =
            runtime.new_actor_with_name::<State>("PatchActorsReadyObserver".to_string());
        actor.model.tx = Some(self.tx);

        // Subscribe to PatchActorsReady broadcasts
        actor.handle().subscribe::<PatchActorsReady>().await;

        actor.act_on::<PatchActorsReady>(|actor, context| {
            let msg = context.message().clone();
            let tx = actor.model.tx.clone();
            Reply::pending(async move {
                if let Some(tx) = tx {
                    let _ = tx.send(msg).await;
                }
            })
        });

        actor.start().await;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_half_life_decay() {
        let mut value = 1.0;
        half_life_decay(&mut value, 600_000, 600_000); // one half-life
        assert!((value - 0.5).abs() < 0.01);
    }
}
